\chapter{Конструкторская часть}

\section{Вспомогательные структуры} 
Для программной реализации алгоритма сначала опишем вспомогательную структуру
\begin{itemize}
\item \texttt{Node}.
	\begin{itemize}
		\item поля: string name, Node* parent,	Node* left\_child, Node* right\_child,
		\item инициализация: Node(string nm, Node* prt, Node* lchild, Node* rchild), Node(str\-ing nm),
	\end{itemize}
\end{itemize}

\section{Алгоритм кодирования по методу Хаффмана}
Алгоритм реализован в виде класса \texttt{HuffmanTree}, предоставляющего методы для построения дерева Хаффмана, создания таблицы кодирования, записи таблицы в файл, а также кодирования строки в бинарный формат.

\subsection*{Поля и начальная настройка}
\begin{enumerate}
	\item \texttt{root}
	\begin{itemize}
		\item тип: \texttt{Node*},
		\item описание: указатель на корень дерева Хаффмана.
	\end{itemize}
	\item \texttt{letters}
	\begin{itemize}
		\item тип: \texttt{vector<char>},
		\item описание: массив символов, содержащий все уникальные символы исходного текста.
	\end{itemize}
\end{enumerate}

\subsection*{Этапы работы алгоритма}

\subsection{Метод \texttt{get\_codes}}
Этот метод рекурсивно генерирует коды Хаффмана для каждого символа.
\begin{enumerate}
	\item проверяем, является ли текущая вершина листом (нет дочерних вершин):
	\begin{itemize}
		\item если да, добавляем пару (символ, код) в таблицу \texttt{table},
		\item если нет, рекурсивно вызываем метод для левого и правого дочерних узлов, добавляя \texttt{0} и \texttt{1} к коду соответственно.
	\end{itemize}
\end{enumerate}

\subsection{Метод \texttt{set\_letters}}
Метод резервирует память под переданный массив и копирует его символы в поле \texttt{letters}.
\begin{enumerate}
	\item очищаем массив \texttt{letters},
	\item резервируем память под новый массив размером \texttt{buf.size()},
	\item используем метод \texttt{append\_range} для копирования данных из \texttt{buf} в \texttt{letters}.
\end{enumerate}

\subsection{Метод \texttt{make\_tree}}
Этот метод строит дерево Хаффмана, используя очередь с приоритетами.
\begin{enumerate}
	\item объявляем временные переменные для хранения текущих узлов, их весов и общей карты узлов \texttt{storage}, в виде словаря,
	\item пока в очереди больше одного элемента:
	\begin{itemize}
		\item извлекаем два узла с минимальными весами из очереди,
		\item создаем новый узел с суммарным весом извлеченных узлов,
		\item связываем новый узел с извлеченными узлами как с левым и правым потомками,
		\item добавляем новый узел в очередь,
		\item обновляем карту \texttt{storage}, связывая строковое имя нового узла (конкатенация строк полей имён потомков) с указателем на него.
	\end{itemize}
	\item после завершения цикла последний узел в очереди становится корнем дерева.
\end{enumerate}

\subsection{Метод \texttt{create\_table}}
Метод создает таблицу кодов Хаффмана и сохраняет её в текстовый файл.
\begin{enumerate}
	\item открываем файл \texttt{table.txt} для записи,
	\item вызываем метод \texttt{get\_codes} для заполнения таблицы кодов,
	\item записываем размеры исходной матрицы (\texttt{ROWS} и \texttt{COLUMNS}) и пары (символ, код) в файл,
	\item закрываем файл.
\end{enumerate}

\subsection{Метод \texttt{code}}
Метод кодирует строку на основе таблицы Хаффмана и сохраняет закодированные данные в бинарный файл.
\begin{enumerate}
	\item для каждого символа исходной строки добавляем его код из таблицы в результирующую строку \texttt{coded\_flow},
	\item пакуем последовательность бит в массив байтов \texttt{packed\_data}:
	\begin{itemize}
		\item сдвигаем текущий байт влево и добавляем очередной бит,
		\item когда байт заполняется(восьмью битами), добавляем его в массив \texttt{packed\_data},
		\item если остались незаполненные биты, дополняем их незначимыми нулями.
	\end{itemize}
	\item записываем массив \texttt{packed\_data} в бинарный файл \texttt{coded.bin}.
\end{enumerate}


\clearpage
