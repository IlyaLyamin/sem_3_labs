\chapter{Конструкторская часть}

\section{Вспомогательные структуры} 
Для программной реализации алгоритма сначала необходимо описать вспомогательную структуру \texttt{Node}.
\begin{itemize}
	\item поля --- string name, Node* parent,	Node* left\_child, Node* right\_child,
	\item инициализация --- Node(string nm, Node* prt, Node* lchild, Node* rchild), Node(str\-ing nm).
\end{itemize}

\section{Алгоритм кодирования по методу Хаффмана}
Алгоритм кодирования реализован в классе \texttt{HuffmanTree}, который предоставляет собой методы для построения дерева Хаффмана, создания таблицы кодирования, записи таблицы в файл, а также кодирования строки в бинарный формат.

\subsection*{Поля и начальная настройка класса \texttt{HuffmanTree}}
\begin{enumerate}
	\item \texttt{root} --- указатель на корень дерева Хаффмана, поле типа \texttt{Node*};	
	\item \texttt{letters} --- массив символов, содержащий все уникальные символы исходного текста, поле типа \texttt{vector<char>};
\end{enumerate}

\subsection*{Методы класса}

\subsection{\texttt{get\_codes}}
Метод рекурсивно составляет коды Хаффмана для каждого символа в файле.

\subsection*{Входные данные}
\begin{enumerate}
	\item \texttt{string} --- код родителя  с добавленной цифрой (0 или 1), поле типа \texttt{string};	
	\item \texttt{current\_node} --- указатель на текущую вершину, поле типа \texttt{Node*};
	\item \texttt{table} --- cловарь содержащий символы из файла, поле типа \\ \texttt{map<char, std::string>$\&$ table};
\end{enumerate}

\subsection*{Выходные данные}
Это рекурсивная функция вызывающая саму себя с изменёнными аргументами.

\subsection*{Этапы работы алгоритма}
Проверка, является ли \texttt{current\_node} листом дерева (нет дочерних вершин):
\begin{itemize}
	\item если да, добавить пару (символ, код) в таблицу \texttt{table},
	\item если нет, рекурсивно вызвать метод для левого и правого дочерних узлов, добавляя соответственно 2 и 1 к \texttt{string}.
\end{itemize}
	
\subsection{\texttt{set\_letters}}
Метод резервирует память под переданный массив и копирует его символы в поле \texttt{letters}.

\subsection*{Входные данные}
\texttt{buf} --- набор всех уникальных элементов считанных из файла, поле типа \texttt{const \\ vector<char>$\&$}.

\subsection*{Этапы работы алгоритма}
\begin{enumerate}
	\item очистить массив \texttt{letters},
	\item зарезервировать память под новый массив размером \texttt{buf.size()},
	\item использовать метод \texttt{append\_range} для копирования данных из \texttt{buf} в \texttt{letters}.
\end{enumerate}

\subsection{\texttt{make\_tree}}
Этот метод строит дерево Хаффмана, используя очередь с приоритетам(более высокий приоритет у наиболее часто встречающегося элемента), которую принимает в качестве аргумента.

\subsection*{Входные данные}
\texttt{q} --- очередь пар элементов (символ, частота в файле), поле типа \\ \texttt{priority\_queue<my\_value\_t, my\_container\_t, CMP>$\&$}, где \texttt{my\_value\_t} --- \texttt{pair<string, size\_t>}, \texttt{my\_container\_t} --- \texttt{vector<my\_value\_t>}, \texttt{CMP} --- функция компаратор(сравнивает частоту встречи элементов в тексте).

\subsection*{Этапы работы алгоритма}
\begin{enumerate}
	\item объявить временные переменные для хранения текущих узлов, их весов и общей карты узлов \texttt{storage}, в виде словаря,
	\item пока в очереди больше одного элемента:
	\begin{itemize}
		\item извлечь два узла с минимальными весами из очереди,
		\item создать новый узел с суммарным весом извлеченных узлов,
		\item связать новый узел с извлеченными узлами как с левым и правым потомками,
		\item добавить новый узел в очередь,
		\item обновить карту \texttt{storage}, связывая строковое имя нового узла (конкатенация строк полей имён потомков) с указателем на него.
	\end{itemize}
	\item после завершения цикла последний узел в очереди становится корнем дерева.
\end{enumerate}

\subsection{\texttt{create\_table}}
Метод создает таблицу кодов Хаффмана и сохраняет её в текстовый файл.

\subsection*{Входные данные}
\texttt{q} --- вектор пар элементов (символ, частота в файле), поле типа \texttt{vector<my\_value\_t>}.

\subsection*{Выходные данные}
\texttt{table} --- таблица пар (символ код), поле типа \texttt{map<char, string>}.

\subsection*{Этапы работы алгоритма}
\begin{enumerate}
	\item открыть файл \texttt{table.txt} для записи,
	\item вызвать метод \texttt{get\_codes} для заполнения таблицы кодов,
	\item записать размеры исходной матрицы (\texttt{ROWS} и \texttt{COLUMNS}) и пары (символ, код) в файл,
	\item найти общее количество бит в файле перемножив частоту появления в файле элемента на длину его кода, и сохраняем остаток от деления этого числа на 8, в глобальную переменную \texttt{USEFUL},
	\item закрыть файл.
\end{enumerate}

\subsection{\texttt{code}}
Метод кодирует строку с данными, которую он принимает как аргумент, на основе таблицы Хаффмана, сохраняет количество полезных бит \texttt{USEFUL} и закодированные данные в бинарный файл.

\subsection*{Входные данные}
\begin{enumerate}
	\item \texttt{flow} --- строка для кодирования \texttt{string};
	\item \texttt{table} --- словарь содержащий пары (символ, код)\texttt{map<char, std::string>$\&$};
\end{enumerate}

\subsection*{Этапы работы алгоритма}
\begin{enumerate}
	\item записываем переменную \texttt{USEFUL} в бинарном виде в результирующую строку \texttt{co\-ded\_flow},
	\item для каждого символа исходной строки добавить его код из таблицы в результирующую строку \texttt{co\-ded\_flow},
	\item упаковать последовательность бит в массив байтов \texttt{packed\_data}:
	\begin{itemize}
		\item сдвинуть текущий байт влево и добавляем очередной бит(элемент из \texttt{co\-ded\_flow}),
		\item когда байт заполняется(восьмью битами), добавить его в массив \texttt{packed\_data},
		\item если остались незаполненные биты, дополнить их незначимыми нулями.
	\end{itemize}
	\item записать массив \texttt{packed\_data} в бинарный файл \texttt{coded.bin}.
\end{enumerate}

\section{Алгоритм декодирования}
Для реализации алгоритма необходимо выполнить следующие действия
\begin{enumerate}
	\item открыть файл \texttt{coded.bin} для записи,
	\item считать первый байт, в котором хранится количество полезных бит в последнем байте, и записать это число в переменную \texttt{USE} типа \texttt{int},
	\item считывать все байты целиком до предпоследнего включительно,
	\item дойдя до последнего байта записать только \texttt{USE} бит из него,
	\item цикл по всем считанным битам,
	\begin{itemize}
		\item записать в буфер значение бита,
		\item проверить, что в таблице нет элемента с таким кодом,
		\item в случае если такой элемент есть, то вывести его в консоль и очистить буфер.
	\end{itemize}
	\item конец алгоритма.
\end{enumerate}
\clearpage
