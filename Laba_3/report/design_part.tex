\chapter{Конструкторская часть}

\section{Вспомогательные функции} 
Для программной реализации алгоритма сначала опишем вспомогательные функции
\begin{enumerate}
	\item \texttt{is\_num(char elem)}
	\begin{itemize}
		\item тип возвращаемого значения: bool,
		\item описание: определяет, принадлежит ли данный элемент набору '123456789x.',
	\end{itemize}
	
	\item \texttt{is\_oper(char elem)}
	\begin{itemize}
		\item тип возвращаемого значения: bool,
		\item описание: определяет, принадлежит ли данный элемент набору '+-/*\^{}',
	\end{itemize}
	
	\item \texttt{is\_bark(char elem)}
	\begin{itemize}
		\item тип возвращаемого значения: bool,
		\item описание: определяет, принадлежит ли данный элемент набору '()',
	\end{itemize}
	
	\item \texttt{ord(string elem)}
	\begin{itemize}
		\item тип возвращаемого значения: int,
		\item описание: определяет порядок выполнения операции при инфиксной записи в соответствии со следующим словарём,
		\begin{lstlisting}[label = list1, caption = словарь с порядками операций]
			map<string, unsigned> operators{{"-u", 2},
				{"cos", 4},
				{"sin", 4},
				{"tg", 4},
				{"ctg", 4},
				{"acos", 4},
				{"asin", 4},
				{"atg", 4},
				{"actg", 4},
				{"^", 3},
				{"*", 2},
				{ "/", 2 },
				{ "+", 1 },
				{ "-", 1 }
			};
        \end{lstlisting}
	\end{itemize}
	
	\item \texttt{arithm(flaot num\_1, flaot num\_2, string operator)}
	\begin{itemize}
		\item тип возвращаемого значения: float,
		\item описание: находит значение получаемое в результате применения заданного бинарного оператора (operator) к двум операндам (num\_1, num\_2),
	\end{itemize}
	\newpage
	
	\item \texttt{arithm(flaot num, string operator)}
	\begin{itemize}
		\item тип возвращаемого значения: float,
		\item описание: находит значение получаемое в результате применения заданного унарного оператора (operator) к одному операнду (num),
	\end{itemize}
\end{enumerate}
Для взаимодействия со стеком разработаны следующие функции
\begin{enumerate}
	\item \texttt{IsEmpty}
	\begin{itemize}
		\item описание: проверяет, пуст ли стек,
		\item возвращает: \texttt{true}, если стек пуст; в противном случае \texttt{false},
	\end{itemize}
	
	\item \texttt{IsFull}
	\begin{itemize}
		\item описание: проверяет, полон ли стек,
		\item возвращает: \texttt{true}, если стек полон; в противном случае \texttt{false},
	\end{itemize}
	
	\item \texttt{Push}
	\begin{itemize}
		\item описание: добавляет новый элемент на верх стека,
	\end{itemize}
	
	\item \texttt{Pop}
	\begin{itemize}
		\item описание: удаляет верхний элемент из стека и сохраняет его в параметре по ссылке,
		\item возвращает: \texttt{true}, если операция успешна (т. е. стек не пуст); в противном случае \texttt{false},
	\end{itemize}
	
	\item \texttt{Peek}
	\begin{itemize}
		\item описание: извлекает верхний элемент стека без его удаления, сохраняя его в параметре по ссылке,
		\item возвращает: \texttt{true}, если операция успешна (т. е. стек не пуст); в противном случае \texttt{false},
	\end{itemize}
	
	\item \texttt{print}
	\begin{itemize}
		\item описание: отображает элементы стека,
	\end{itemize}
\end{enumerate}
\section{Алгоритм валидации строки}
Алгоритм валидации строки направлен на выявление невалидных символов, которые вызовут ошибку в последующей реализации программы. Результат работы этого алгоритма это строка проверенная по следующим критериям
\begin{enumerate}
	\item отсутствие неизвестных функций,
	\item правильная расстановка скобок,
	\item правильная расстановка операторов,
	\item перевод обычного минуса в бинарный при отсутствии левого операнда,
	\item явное деление на ноль,
\end{enumerate}
\newpage
\subsection*{Этапы работы алгоритма}
\begin{enumerate}
	\item перевод строки в нижний регистр и проверка скобок	
	\begin{itemize}
		\item переводим строку в нижний регистр функцией lower(), встроенной в стандартную библиотеку c++,
		\item для отслеживания правильности расстановок скобок с помощью переменной $i$ с изначальным значением 0 проходимся по всей строке через цикл и при наличии открывающейся строки прибавляем 1 к i, а в случае закрывающейся вычитаем 1. Если на протяжении всего цикла значение i ни разу не опускалось ниже 0 и к концу цикла оно равно 0, то в строке скобки расставлены правильно,
	\end{itemize}
	
	\item проверка на правильность введённых функций,
	\item проверка на корректность расстановки операторов,
\end{enumerate}
\section{Алгоритм токенизации строки}
Задача данного алгоритма составить массив с данными формата \texttt{string}, который содержит операторы, операнды и числа в том порядке, в котором они были поданы пользователем (в виде инфиксной записи).
\subsection*{Поля и начальная настройка}
\begin{enumerate}
	\item \texttt{str}
	\begin{itemize}
		\item тип: \texttt{string},
		\item описание: изначальная строка, содержащая все элементы введённые пользователем,
	\end{itemize}
	
	\item \texttt{arr}
	\begin{itemize}
		\item тип: \texttt{string*},
		\item описание: результирующий массив, в который добавляются элементы арифметического выражения,
	\end{itemize}
	
	\item \texttt{len}
	\begin{itemize}
		\item тип: \texttt{int}
		\item описание: количество элементов в изначальной строке,
	\end{itemize}
	
	\item \texttt{cur}
	\begin{itemize}
		\item тип: \texttt{string},
		\item описание: локальный элемент сохраняющий терм(токен) и добавляющий его в результирующий массив при выполнении определённых условий, после этого он обнуляется,
	\end{itemize}
	
	\item \texttt{ind\_arr}
	\begin{itemize}
		\item тип: \texttt{int}
		\item описание: Счетчик для определения длины результирующего массива,
	\end{itemize}
\end{enumerate}

\subsection*{Этапы работы алгоритма}
Функция \texttt{create\_arr} последовательно обрабатывает элементы входной строки \texttt{str}, выполняя следующие действия(i --- индикатор итерации).

\begin{enumerate}
	\item из строки \texttt{str} извлекается первый элемент и сохраняется в переменной \texttt{cur},
	\begin{itemize}
		\item если первый элемент \texttt{str} --- оператор
		\begin{itemize}
			\item если элемент --- $'-'$ то \texttt{arr[ind] == "u-"},
			\item иначе \texttt{arr[ind\_arr] = cur},
		\end{itemize}
		строка \texttt{cur} обнуляется , к индикатору \texttt{ind\_arr} прибавляется 1,
		
		\item если текущий элемент \texttt{str} --- число
		\begin{itemize}
			\item если следующий элемент тоже число, то переходим к следующей итерации,
			\item иначе \texttt{arr[ind\_arr] = cur}, прибавляем 1 к \texttt{ind\_arr} и очищаем \texttt{cur},
		\end{itemize}
		
		\item если текущий элемент \texttt{str} --- скобка,
		\begin{itemize}
			\item \texttt{arr[ind\_arr] = cur}, прибавляем 1 к \texttt{ind\_arr} и очищаем \texttt{cur},
		\end{itemize}
		
		\item иначе
		\begin{itemize}
			\item если следующий элемент открывающаяся скобка или текущий элемент последний, то присваиваем \texttt{arr[ind\_arr] = cur}, прибавляем 1 к \texttt{ind\_arr} и очищаем \texttt{cur},
			\item иначе продолжаем итерацию,
		\end{itemize}
	\end{itemize}
	
	\item цикл продолжается до того момента как не будут перебраны все элементы троки,
	\item функция возвращает словарь \texttt{arr} с токенами,
\end{enumerate}

\section{Алгоритм перевода из инфиксной записи в постфиксную}
Для преобразования строки, содержащей инфиксную запись математического выражения, в постфиксную (обратную польскую) запись разработана функция \texttt{create\_postf\_arr}. Алгоритм будет использовать стек и контейнер для хранения промежуточных результатов. Ниже приведено описание всех частей алгоритма.
\subsection*{Поля и начальная настройка}
\begin{enumerate}
	\item \texttt{str}
	\begin{itemize}
		\item тип: \texttt{string},
		\item описание: входящая строка содержащая инфиксную запись,
	\end{itemize}
	
	\item \texttt{stack}
	\begin{itemize}
		\item тип: \texttt{stack<string>},
		\item описание: пустой стек,
	\end{itemize}
	
	\item \texttt{postf\_arr}
	\begin{itemize}
		\item тип: \texttt{string*},
		\item описание: хранит результат в постфиксной записи, который будет сформирован и возвращен функцией,
	\end{itemize}
	
	\item \texttt{cur}
	\begin{itemize}
		\item тип: индекс обозреваемого элемента (на нуле),
	\end{itemize}
\end{enumerate}

\subsection*{Этапы работы алгоритма}
Алгоритм выполняет обработку каждого элемента инфиксного выражения по очереди до того момента, пока курсор находится в пределе в пределах входной строки\texttt{str}.

\begin{enumerate}
	\item если элемент под курсором число, то поместить его в ответ \texttt{posf\_arr},
	
	\item если под курсором открывающаяся скобка \texttt{(}, она помещается в стек \texttt{stack},
	
	\item если под курсором закрывающаяся скобка \texttt{)}, из стека \texttt{a} извлекаются элементы и добавляются в \texttt{postf\_arr} до тех пор, пока не встретится открывающая скобка \texttt{(}, либо пока не \texttt{stack} не будет пуст,

	\item если \texttt{s} является оператором или тригонометрической функцией \label{1},
	\begin{enumerate}
		\item если стек \texttt{stack} пуст, оператор помещается в стек,
		\item если верхний знак в стеке это открывающая скобка, \texttt{(}, оператор помещается в \texttt{stack},
		\item если приоритет оператора под курсором выше или равен приоритету оператора на вершине стека (проверяется с помощью функции \texttt{ord}), оператор помещается в \texttt{stack},
		\item в противном случае оператор из вершины стека извлекается и добавляется в \texttt{postf\_arr}, после чего алгоритм возвращаться к пункту \ref{1},
	\end{enumerate}
	
	\item после окончания цикла, все элементы из стека \texttt{stack} помещаются в ответ \texttt{postf\_arr},
\end{enumerate}

\subsection*{Результат}
Функция возвращает динамический массив \texttt{postf\_arr}, содержащий исходное выражение в постфиксной записи.

\section{Алгоритм вычисления выражения в постфиксной записи}
Функция \texttt{calculate} разработана для вычисления значения математического выражения, заданного в строке \texttt{str}. Выражение подается в инфиксной записи и преобразуется в постфиксную запись для вычисления, используя стек для хранения промежуточных значений и операндов. Результат вычислений возвращается через ссылку \texttt{ans}.

\subsection*{Поля и начальная настройка}
\begin{enumerate}
	\item \texttt{postf}
	\begin{itemize}
		\item тип: \texttt{string*},
		\item описание: динамический массив, содержащий элементы выражения в постфиксной записи, полученный после преобразования \texttt{str} с помощью функции \texttt{create\_post\_arr},
	\end{itemize}
	
	\item \texttt{stack}
	\begin{itemize}
		\item тип: \texttt{Stack<float>},
		\item описание: вспомогательный стек для хранения числовых значений и промежуточных результатов операций,
	\end{itemize}
	
	\item \texttt{cur}
	\begin{itemize}
		\item тип: \texttt{int},
		\item описание: индекс обозреваемого элемента (на нуле),
	\end{itemize}
\end{enumerate}

\subsection*{Этапы работы алгоритма}
Функция выполняет вычисления для каждого элемента постфиксного выражения.
\begin{enumerate}
	\item если под курсором число то помещаем его в стек \texttt{stack},
	
	\item если под курсором знак операции то,
	\begin{itemize}
		\item попытаться извлечь из стека необходимое количество аргументов. В случае неудачи, выдать ошибку и прервать цикл,
		\item если удалось извлечь необходимое количество аргументов, то произвести со\-ответствующие вычисления и поместить результат в стек,
	\end{itemize}
	
	\item конец цикла,
\end{enumerate}

\clearpage
